# Feature Specification: Qeel - 量的トレーディング向けバックテストライブラリ

**Feature Branch**: `001-qeel-core`
**Created**: 2025-11-25
**Status**: Draft
**Input**: User description: "本プロジェクトのコア要件・仕様を定義します。バックテストから実運用へのシームレスな接続を可能とするバックテストライブラリを開発します。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - バックテストの実行と結果検証 (Priority: P1)

クオンツアナリストが、外部で検証済みのシグナル計算ロジックをバックテストループに組み込み、過去データを用いて戦略のパフォーマンスを評価する。

**Why this priority**: バックテスト機能はシステムのコア価値であり、これがなければ他の機能も意味を持たない。戦略の有効性を検証する最重要機能。

**Independent Test**: シグナル計算クラスと市場データを用意し、バックテストを実行してリターン指標（シャープレシオ、最大ドローダウンなど）が算出されることで検証可能。

**Acceptance Scenarios**:

1. **Given** シグナル計算クラスと過去の市場データ（OHLCV）が用意されている、**When** バックテストを実行する、**Then** 日次リターン、累積リターン、シャープレシオ、最大ドローダウンなどのパフォーマンス指標が算出される
2. **Given** 複数銘柄の市場データが用意されている、**When** ポートフォリオ戦略でバックテストを実行する、**Then** 銘柄ごと、およびポートフォリオ全体のパフォーマンス指標が算出される
3. **Given** コスト設定（手数料、スリッページ、マーケットインパクト）がtomlで定義されている、**When** バックテストを実行する、**Then** コストを考慮したリターンが算出される

---

### User Story 2 - 実運用への転用 (Priority: P2)

クオンツアナリストが、バックテストで検証した戦略ロジックを、コードを変更することなく実運用環境に展開する。

**Why this priority**: システムの差別化要因であり、バックテストと実運用の完全な再現性を保証する。P1のバックテスト機能が動作した後に価値を発揮する。

**Independent Test**: バックテストで使用した同一のシグナル計算クラスと執行ロジックを用い、当日を指定して単一iterationを実行し、実際のAPI経由で注文が送信されることで検証可能。

**Acceptance Scenarios**:

1. **Given** バックテストで検証済みの戦略クラスが存在する、**When** 実運用モードで当日を指定してiterationを実行する、**Then** 取引所APIを通じて実際の注文が送信される
2. **Given** バックテストと実運用で同一の市場データとコンテキスト（ポジション情報）が用意されている、**When** 同一日時でそれぞれ実行する、**Then** 生成される注文内容（銘柄、数量、価格）が完全に一致する
3. **Given** 実運用で注文が約定された、**When** 約定情報を取得する、**Then** 約定情報が共通フォーマットで保存され、パフォーマンス計算に利用できる

---

### User Story 3 - シグナル評価の分布評価 (Priority: P3)

クオンツアナリストが、シグナル計算ロジックを全期間のデータに対して一括実行し、シグナルの有効性をリターンとの順位相関係数で評価する。

**Why this priority**: 戦略開発の初期段階で有用だが、バックテストとは独立した分析機能。P1、P2が完成した後に追加することで、より効率的な戦略開発が可能になる。

**Independent Test**: シグナル計算クラスとリターン計算ロジックを用意し、全期間のデータに対してシグナルを算出し、年次・パラメータ別の順位相関係数の分布が可視化されることで検証可能。

**Acceptance Scenarios**:

1. **Given** シグナル計算クラスとパラメータグリッドが定義されている、**When** 全期間のデータに対してシグナルを一括計算する、**Then** 各パラメータ組み合わせごとのシグナル系列が生成される
2. **Given** シグナル系列とリターン系列が用意されている、**When** 評価を実行する、**Then** シグナルとリターンの順位相関係数が計算される
3. **Given** 年次別・パラメータ別の順位相関係数が算出されている、**When** 可視化を実行する、**Then** 分布図が生成され、シグナルのロバスト性が評価できる

---

### User Story 4 - バックテストと実運用の乖離検証 (Priority: P3)

クオンツアナリストが、実運用の結果とバックテストの結果を比較し、想定外の乖離がないかを確認する。

**Why this priority**: 実運用開始後の品質保証に重要だが、P2の実運用機能が稼働した後に意味を持つ。

**Independent Test**: 実運用の約定情報とバックテスト結果を用意し、同一期間のリターンを比較して差分が可視化されることで検証可能。

**Acceptance Scenarios**:

1. **Given** 実運用の約定情報とバックテスト結果が同一期間で存在する、**When** 乖離可視化を実行する、**Then** 日次リターンの差分、累積リターンの差分がグラフで表示される
2. **Given** 乖離が発見された、**When** 詳細ログを確認する、**Then** 乖離の原因（スリッページ、約定タイミング、データ品質など）を特定できる情報が提供される

---

### Edge Cases

- **データ欠損**: データソースに欠損値が含まれる場合、システムはNaN/nullのまま処理を継続する。ユーザは必要に応じて、シグナル計算クラス内で欠損処理（forward fill、dropなど）を実装する
- **異常値**: 価格がゼロまたは異常に高い値の場合、システムは検出せず、ユーザがシグナル計算ロジック内で異常値検出とフィルタリングを実装する責任を持つ
- **toml設定バリデーション**: toml設定ファイルが不正な形式、矛盾した設定、または必須パラメータの欠落を含む場合、システムは起動前にPydanticモデルで厳密にバリデーションし、具体的なエラーメッセージ（不正な項目名、型不一致、矛盾箇所）を出力して停止する
- **銘柄ユニバースの動的決定**: 複数銘柄のバックテストでは、各iterationにおいて当日にデータが存在する銘柄のみを自然にユニバース（対象銘柄群）とする。一部の銘柄のデータが不足している場合でも、警告を出さず、データが存在する銘柄のみで処理を継続する

## Requirements *(mandatory)*

### Functional Requirements

#### バックテスト実行

- **FR-001**: システムは、固定幅（日足、週足、時間足など）でのiterationベースのバックテストループを提供しなければならない
- **FR-002**: システムは、各iterationで複数のデータソース（OHLCV、決算情報など）を任意のwindowサイズで取得できなければならない
- **FR-003**: システムは、各データソースが実際に利用可能な日時を示すdatetime列を必須とし、リーク防止のために厳密に管理しなければならない
- **FR-004**: システムは、iteration内で以下のステップを分離して実装できなければならない：
  - シグナル計算（calculate_signals）: ユーザが抽象基底クラス`BaseSignalCalculator`を継承し、Pydanticモデルでパラメータを定義し、`calculate()`メソッドをオーバーライドして実装。入出力はPolars DataFrameを使用
  - ポートフォリオ構築（construct_portfolio）: ユーザが抽象基底クラス`BasePortfolioConstructor`を継承し、Pydanticモデルでパラメータを定義し、`construct()`メソッドをオーバーライドして実装。入出力はPolars DataFrameを使用。出力DataFrameには必須列として`datetime`と`symbol`を含み、オプション列として執行条件計算に必要なメタデータ（シグナル強度、優先度、タグ等）を含められる。デフォルト実装（シグナル上位N銘柄選定）を提供
  - 執行条件計算（create_orders）: ユーザが抽象基底クラス`BaseOrderCreator`を継承し、Pydanticモデルでパラメータを定義し、`create()`メソッドをオーバーライドして実装。入力は`portfolio_plan`（構築済みポートフォリオDataFrame、メタデータ含む）、`current_positions`（現在のポジション）、`ohlcv`（OHLCV価格データ）。`BasePortfolioConstructor`から渡されたメタデータ（シグナル強度、優先度等）を活用して柔軟な注文生成が可能。デフォルト実装（等ウェイトポートフォリオ、成行注文）を提供
  - 執行（submit_orders）
  - 約定情報取得（fetch_fill_reports）: 出力はPolars DataFrameを使用
  - パフォーマンス計算（calculate_metrics）: 入出力はPolars DataFrameを使用
- **FR-004-1**: システムは、各メソッドおよびコンポーネントの入出力データをPydanticモデルでスキーマ定義し、実行時にバリデーションを行わなければならない。特に以下のデータ構造はPydanticモデルで厳密に管理される：
  - シグナル計算クラスのパラメータ
  - 各メソッドの入力データ（Market Data、Position、Order等）
  - 各メソッドの出力データ（Signal、Order、Fill Report等）
  - コンテキスト情報（ポジション、シグナル、ポートフォリオ計画等）
- **FR-005**: システムは、ポジション情報、選択銘柄、シグナルなどのコンテキストを各iteration間で永続化し、次のiterationで参照できなければならない
- **FR-006**: システムは、コスト（手数料、スリッページ、マーケットインパクト）をtoml設定から読み込み、リターン計算に反映しなければならない
- **FR-007**: システムは、複数銘柄の同時トレードに対応しなければならない
- **FR-007-1**: システムは、各iterationにおいて、当日にデータが存在する銘柄のみをユニバース（対象銘柄群）として自動的に決定しなければならない。一部の銘柄のデータが不足している場合でも、警告を出さず、データが存在する銘柄のみで処理を継続しなければならない。ユニバースの決定方法は以下の通り：
  - 設定で銘柄リストが指定されている場合、そのリストを`symbols`引数として`BaseDataSource.fetch()`に渡す
  - data_sourceがこのリストでフィルタリングした結果、当日データが存在する銘柄のみが残る（自然に積集合になる）
  - 設定で銘柄リストが指定されていない場合、当日に存在するすべての銘柄が対象となる

#### 実運用への転用

- **FR-008**: システムは、バックテストで使用したシグナル計算クラスを、コード変更なしで実運用に転用できなければならない
- **FR-009**: システムは、実運用時に当日を指定して単一iterationを実行し、バックテストと完全な再現性を保証しなければならない
- **FR-010**: システムは、実運用時の執行ロジック（submit_orders）と約定情報取得ロジック（fetch_fill_reports）を、ユーザが取引所APIに応じてカスタム実装できる拡張ポイントを提供しなければならない
- **FR-011**: システムは、バックテスト時にモックで約定をシミュレートし、実運用時に実際のAPIに差し替え可能でなければならない。数量・価格の最小単位丸めは、バックテスト時のモックではスキップし、実運用時のAPI層で取引所の仕様に応じて実施する
- **FR-012**: システムは、実運用の約定情報を共通フォーマットで保存し、バックテストと同一のパフォーマンス計算ロジックを適用できなければならない

#### シグナル評価

- **FR-013**: システムは、シグナル計算クラス（`BaseSignalCalculator`を継承）に対してPydanticモデルでパラメータグリッドを定義し、全期間のデータに対して一括でシグナルを計算できなければならない。入出力はPolars DataFrameを使用する
- **FR-014**: システムは、リターン計算ロジックを抽象基底クラス`BaseReturnCalculator`として定義し、ユーザが`calculate()`メソッドをオーバーライドして実装できなければならない。リターンは、current_datetimeで生成されたシグナルに対する未来の実現リターンを表し、リーク（ルックアヘッドバイアス）防止のため、過去データを使用してはならない。この計算結果をシグナルと`datetime`, `symbol`で結合して順位相関係数を評価できなければならない
- **FR-015**: システムは、年次別・パラメータ別の順位相関係数を計算し、分布として可視化できなければならない

#### データ管理

- **FR-016**: システムは、各データソースのパラメータ（datetime列名、利用可能時刻のオフセット、提供window）をtoml設定で管理しなければならない
- **FR-017**: システムは、データソースの読み込み元をユーザが柔軟に定義できるインターフェースを提供しなければならない（Parquet標準、データベース、APIなど）
- **FR-017-1**: システムは、データソースに欠損値が含まれる場合、NaN/nullのまま処理を継続しなければならない。欠損値処理（forward fill、interpolation、dropなど）は、ユーザがシグナル計算クラス内で実装する責任を持つ

#### コンテキスト管理

- **FR-018**: システムは、iteration内の各ステップの出力（シグナル、ポートフォリオ計画、注文）を個別に日付ごとにパーティショニングして保存しなければならない。ポジション情報は取引所APIクライアントから動的に取得されるため保存対象外。DataFrameはParquet形式で保存される。年月でディレクトリ分割し（YYYY/MM/）、トレーサビリティを確保する。読み込み時は、最新日付または指定日付の各要素を復元し、ポジションは取引所APIクライアントから取得してコンテキストを構築できなければならない
- **FR-019**: システムは、General設定で指定されたストレージタイプ（local/s3）に基づき、IOレイヤーが自動的にContextの保存先を判断しなければならない。ContextStoreはIOレイヤー経由でデータ読み書きを行い、Local/S3の判別ロジックを持たない

#### 結果分析と可視化

- **FR-020**: システムは、約定情報から共通のパフォーマンス指標（シャープレシオ、最大ドローダウン、勝率、日次リターンなど）を計算できなければならない
- **FR-021**: システムは、バックテスト結果と実運用結果の乖離を可視化できなければならない
- **FR-022**: システムは、期間を指定してバックテスト・実運用問わず共通のレポート出力ができなければならない

#### 設定管理

- **FR-023**: システムは、General設定（ストレージタイプ、S3設定）、データソースの定義、コストパラメータ、ループ管理設定をtomlファイルで管理しなければならない。General設定は、データソースやContextの保存参照先の情報を含む
- **FR-024**: システムは、各メソッド（シグナル計算、銘柄選定、執行など）が呼ばれるタイミングを、ループ日付からのtimedeltaとしてtoml設定で定義できなければならない
- **FR-024-1**: システムは、起動前にtoml設定ファイルをPydanticモデルで厳密にバリデーションし、不正な形式、型不一致、矛盾した設定、必須パラメータの欠落が検出された場合、具体的なエラーメッセージ（不正な項目名、期待される型、矛盾箇所）を出力して停止しなければならない

#### 取引日判定

- **FR-025**: システムは、取引日を判定するロジックを提供し、非取引日をスキップできなければならない

#### 実運用支援ユーティリティ

- **FR-026**: システムは、実運用時のExchangeClient実装を支援するため、`qeel.utils`でヘルパー機能を提供しなければならない。ユーザはこれらを自由に利用可能だが、利用は強制ではない
  - APIリトライ（exponential backoff、タイムアウト）: `with_retry(func, max_attempts, timeout, backoff_factor)`
  - エラー通知（Slack等）: `send_slack_notification(webhook_url, message, level)`
  - 数量・価格の丸め処理: `round_to_unit(value, unit)` - 指定した単位に丸める汎用関数

#### ワークスペース管理

- **FR-027**: システムは、環境変数`QEEL_WORKSPACE`でワークスペースディレクトリを指定可能でなければならない。未設定時はカレントディレクトリを参照する。ワークスペース配下には`configs/`、`inputs/`、`outputs/`ディレクトリが配置される
- **FR-027-1**: システムは、`qeel init`コマンドを提供し、ワークスペース構造（configs/inputs/outputs）と設定ファイルテンプレートを自動生成できなければならない

#### IOレイヤー

- **FR-028**: システムは、ファイル読み書きを抽象化するIOレイヤー（BaseIO、LocalIO、S3IO）を提供しなければならない。IOレイヤーは以下の責務を持つ:
  - General設定からストレージタイプを読み取り、適切な実装（LocalIO/S3IO）を返すファクトリメソッド`BaseIO.from_config(general_config)`
  - ワークスペースまたはS3バケットからのベースパス取得
  - 年月パーティショニングディレクトリの生成（YYYY/MM/）
  - dict↔JSON、pl.DataFrame↔Parquetのsave/loadメソッド（ベースパスからの相対パス指定）

### Key Entities

- **Market Data（市場データ）**: データソースから取得される各種データの総称。OHLCV価格データ、決算情報、ニュースデータなど、戦略に必要なあらゆるデータを含む。datetime列を含み、データが実際に利用可能な時刻を決定できる。複数のデータソースが存在し、それぞれ異なるwindowで提供される。Polars DataFrameとして扱われる。OHLCVに特化したスキーマとして`OHLCVSchema`が提供されるが、BaseDataSourceは任意のスキーマを返すことができる。
- **Signal（シグナル）**: 各銘柄に対する定量的な特徴量または予測値。`BaseSignalCalculator`を継承したクラスの`calculate()`メソッドから生成され、銘柄選定の基礎となる。複数シグナル列（signal_momentum, signal_value等の任意の列名）を柔軟に扱える。
- **BaseSignalCalculator（シグナル計算抽象基底クラス）**: ユーザがシグナル計算ロジックを実装するための抽象基底クラス。Pydanticモデルでパラメータを受け取り、`calculate()`メソッドをオーバーライドして、複数のデータソースを入力として受け取り、シグナルを返す。返り値のスキーマ（datetime, symbol列は必須、シグナル列は任意）は実行時バリデーションされる。
- **BasePortfolioConstructor（ポートフォリオ構築抽象基底クラス）**: ユーザがポートフォリオ構築ロジックを実装するための抽象基底クラス。Pydanticモデルでパラメータを受け取り、`construct()`メソッドをオーバーライドして、シグナルDataFrameから構築済みポートフォリオDataFrameを返す。出力DataFrameには必須列として`datetime`と`symbol`を含み、オプション列として執行条件計算に必要なメタデータ（シグナル強度、優先度、タグ等）を含められる。これにより、`OrderCreator`がメタデータを活用して柔軟な注文生成が可能になる。デフォルト実装（シグナル上位N銘柄選定）を提供。
- **BaseOrderCreator（注文生成抽象基底クラス）**: ユーザが注文生成ロジックを実装するための抽象基底クラス。Pydanticモデルでパラメータを受け取り、`create()`メソッドをオーバーライドして、`portfolio_plan`（構築済みポートフォリオDataFrame、メタデータ含む）、`current_positions`（現在のポジション）、`ohlcv`（OHLCV価格データ）から注文DataFrameを返す。`BasePortfolioConstructor`から渡されたメタデータを活用して、シグナル強度に応じた数量調整や優先度別の執行タイミング等の複雑な注文生成が可能。。デフォルト実装（等ウェイトポートフォリオ、成行注文）を提供。
- **BaseReturnCalculator（リターン計算抽象基底クラス）**: ユーザがリターン計算ロジックを実装するための抽象基底クラス。`calculate()`メソッドをオーバーライドして、市場データを入力として受け取り、current_datetimeで生成されたシグナルに対する未来の実現リターン系列を返す。リーク防止のため、リターンは必ず前向き（forward）に計算しなければならない。シグナル評価時に`datetime`, `symbol`で結合され、順位相関係数の計算に使用される。返り値の列スキーマは実行時バリデーションされる。
- **Position（ポジション）**: 現在保有している銘柄と数量。各iterationで参照され、執行条件計算の入力となる。
- **Order（注文）**: 執行する注文の詳細（銘柄、売買区分、数量、価格、注文タイプ）。create_ordersメソッドで生成され、submit_ordersで執行される。
- **Fill Report（約定情報）**: 注文が約定した結果の詳細（注文ID、銘柄、売買区分、数量、価格、手数料、タイムスタンプ）。パフォーマンス計算の入力となる。
- **Context（コンテキスト）**: iterationをまたいで保持される状態（現在日時、シグナル、ポートフォリオ計画、執行条件、ポジション情報など）。各メソッドが参照・更新し、永続化される。
- **Metrics（パフォーマンス指標）**: リターン、シャープレシオ、最大ドローダウンなど、戦略の成績を表す指標。約定情報から計算される。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: バックテストから実運用への転用時に、同一日時・同一データでiterationを実行した場合、生成される注文内容（銘柄、数量、価格）が100%一致する
- **SC-002**: シグナル計算ロジックを外部で検証した後、コードを変更せずにバックテストループに組み込み、1回の実行で期待通りのパフォーマンス指標が算出される
- **SC-003**: データソース追加時、toml設定の追加のみでシステムがそのデータを認識し、指定windowで取得できる（コード変更不要）
- **SC-004**: 実運用時の約定情報とバックテスト結果を比較した際、乖離の原因が特定できる詳細情報が提供される
- **SC-005**: パラメータグリッド評価において、複数のパラメータ組み合わせに対して順位相関係数の分布が可視化され、オーバーフィットの有無を判断できる
- **SC-006**: データ欠損やtoml設定エラーが発生した場合、システムは適切なエラーメッセージを出力し、復旧可能な状態を保つ

## Dependencies & Assumptions

### Dependencies

- **Polars**: データフレーム操作のコアライブラリとして使用。大規模データの高速処理とメモリ効率を提供
- **Pydantic**: すべてのデータ構造のスキーマ定義と実行時バリデーションに使用。型安全性を保証
- **データ提供**: ユーザが市場データ（OHLCV、決算情報など）をParquet形式（推奨）またはカスタムデータソース（データベース、APIなど）で用意する必要がある
- **取引所API**: 実運用時には、取引所が提供するAPI（注文送信、約定情報取得）が利用可能であることが前提
- **ストレージ**: 実運用時のコンテキスト保存には、S3やデータベースなどのストレージサービスが必要

### Assumptions

- **固定幅のみ**: イベントベースのトレード（例: ニュース発表時の即座のトレード）は対象外とし、固定幅（日足、週足、時間足）のみをサポートする
- **外部検証済み**: シグナル計算ロジックは、本システムの分析機能を活用して詳細に検証済みであることを前提とし、バックテストは最終確認として1度のみ実行する
- **Polarsの使用**: すべてのデータフレーム操作にPolarsを使用し、大規模データの高速処理とメモリ効率を重視する。市場データとシグナルは、列名とスキーマが厳密に定義されたテーブル形式（`pl.DataFrame`）で扱う
- **Pydanticによるデータバリデーション**: すべてのデータ構造（パラメータ、入出力、コンテキスト）をPydanticモデルで定義し、実行時のスキーマバリデーションを必須とする
- **ローカルインストール**: システムはパッケージとしてユーザのローカル環境にインストール可能な形式で提供される
- **コスト計算の簡略化**: マーケットインパクト、スリッページ、手数料は、toml設定で定義された固定値またはシンプルなモデルで計算することを前提とする（複雑な動的モデルは対象外）
- **シングルユーザ**: 最初の実装では、複数ユーザの同時アクセスや権限管理は対象外とする
- **リターン計算の標準化**: リターンは単純リターンまたは対数リターンを使用し、より複雑なリターン計算（例: リスク調整後リターン、ベンチマーク相対リターン）はユーザ側で拡張可能とする
- **APIエラーハンドリング**: 実運用時の取引所API呼び出しにおけるエラーハンドリング（リトライ、タイムアウト、レート制限対策、通知など）は、ユーザがExchangeClient実装時に独自に実装する責任を持つ。システムは`qeel.utils`でヘルパー機能を提供するが、その利用はユーザの選択に委ねられる

### Out of Scope

- **リアルタイムティック単位のトレード**: 固定幅（日足、週足、時間足）のみをサポートし、ティック単位のイベントベースのトレードは対象外
- **ポートフォリオ最適化**: ポートフォリオ最適化（例: 平均分散最適化、リスクパリティ）は、ユーザが銘柄選定ロジック内で独自に実装する想定
- **リスク管理**: VaR、CVaRなどの高度なリスク管理指標は、パフォーマンス計算の標準機能には含まない（ユーザ側で拡張可能）
- **マルチアセット対応**: 最初の実装では単一のアセットに焦点を当て、為替、先物、オプションなどのマルチアセット対応は将来の拡張とする
